<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link
      rel="stylesheet"
      href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
      integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z"
      crossorigin="anonymous"
    />
    <link rel="stylesheet" href="./prism.css" />
    <script async defer src="./prism.js"></script>
  </head>
  <body>
    ;
    <h1 id="system-design">System Design</h1>
    <h2 id="points-to-consider-for-system-design">
      Points to Consider for System Design
    </h2>
    <table>
      <tbody>
        <tr class="odd">
          <td style="text-align: center">requirements</td>
          <td style="text-align: center">indexes</td>
        </tr>
        <tr class="even">
          <td style="text-align: center">API creation</td>
          <td style="text-align: center">messaging queue</td>
        </tr>
        <tr class="odd">
          <td style="text-align: center">DB design &amp; table creation</td>
          <td style="text-align: center">consistent hashing</td>
        </tr>
        <tr class="even">
          <td style="text-align: center">logic to solve problem</td>
          <td style="text-align: center">LRU</td>
        </tr>
        <tr class="odd">
          <td style="text-align: center">system workflow</td>
          <td style="text-align: center">Hadoop</td>
        </tr>
        <tr class="even">
          <td style="text-align: center">load balancer</td>
          <td style="text-align: center">Cassandra</td>
        </tr>
        <tr class="odd">
          <td style="text-align: center">caching</td>
          <td style="text-align: center">microservices</td>
        </tr>
        <tr class="even">
          <td style="text-align: center">sharding</td>
          <td style="text-align: center"></td>
        </tr>
      </tbody>
    </table>
    <ul>
      <li>What are the dependencies?</li>
      <li>How do you break your project into independent components?</li>
      <li>What are your primary data objects, nouns, classes?</li>
      <li>What does the data flow between them look like?</li>
    </ul>
    <h2 id="conference-talk-given-by-venkat-subramaniam">
      <a href="https://www.youtube.com/watch?v=llGgO74uXMI"
        >Conference Talk given by Venkat Subramaniam</a
      >
    </h2>
    <p>
      The previous link is a really informative and interesting video about
      software design principles, and he’s a pretty funny guy. It is an old
      video but it’s not coding, so the principles are not really outdated in
      that sense.
    </p>
    <p>Here’s some notes from that talk.</p>
    <h2 id="whats-a-good-design">What’s a good design?</h2>
    <ul>
      <li>When cost of changing is minimal</li>
      <li>easy to change</li>
      <li>
        subject to change along the way and see how it stands up to changing.
      </li>
    </ul>
    <p>
      Sofftware is never written, always rewritten; it has to constantly evolve
    </p>
    <h2 id="how-to-create-good-design">How to create good design</h2>
    <ul>
      <li>keep it simple</li>
      <li>
        first step is let go of ego
        <ul>
          <li>be unemotional</li>
        </ul>
      </li>
      <li>important to have people who can challenge each other</li>
      <li><p>take time to review design and code</p></li>
      <li>
        people who are dangerous to work with:
        <ul>
          <li>those who can’t follow instructions</li>
          <li>those who can only follow instructions</li>
        </ul>
      </li>
    </ul>
    <h2 id="kiss-keep-it-simple-stupid">
      <strong>KISS</strong>: Keep It Simple Stupid
    </h2>
    <h2 id="less-complexity-because-it-makes-code-difficult-to-change">
      less complexity because it makes code difficult to change
    </h2>
    <ol type="1">
      <li>
        Simple keeps you focused.
        <ul>
          <li>
            <strong>imperative code</strong> confuses, going all over and trying
            to figure out where things are
          </li>
          <li>
            <strong>declarative code</strong> tells you what to do, is a lot
            simpler
          </li>
        </ul>
      </li>
      <li>Simple solves only real problem we know about</li>
      <li>Simple fails less</li>
      <li>
        Simple is easier to understand
        <ul>
          <li>
            inherent complexity: from problem domain; nothing you can do about
            it; nature of app, domain
          </li>
          <li>
            accidental complexity: comes from solution used to problem-solve;
            solution brings in complexities; example concurrency
          </li>
        </ul>
      </li>
      <li>Simple is not necessarily familiar</li>
    </ol>
    <p>
      Good design hides inherent complexity and eliminates accidental
      complexity.
    </p>
    <h2 id="yagni-you-arent-going-to-need-it-yet">
      <strong>YAGNI</strong>: You Aren’t Going To Need It (Yet)
    </h2>
    <h3 id="when-should-i-implement-something">
      When should i implement something?
    </h3>
    <ul>
      <li>How much do you know about it?</li>
      <li>Cost of implementing now versus later?</li>
    </ul>
    <p>
      Good design is automatically verifiable (automated testing). Without
      automated testing, it is very difficult to postpone stuff.
    </p>
    <p>
      <strong>cohesion</strong>: narrow, focused, does one thing well; not
      taking on more than one responsibility; lowers cost of developing software
      <strong>coupling</strong>: degree of connectivity among things;
      inheritance is worst form of it; remove if you can
    </p>
    <h3 id="knock-out-before-you-mock-out">Knock out before you mock out</h3>
    <p>Do not keep mocking when you can knock out your dependencies</p>
    <p>Can’t remove all dependencies, but:</p>
    <ol type="1">
      <li>Get rid of it</li>
      <li>Make it loose instead of tight coupling.</li>
      <li>Use caution</li>
    </ol>
    <p>
      <strong>tight coupling</strong>: depending on a class
      <strong>loose coupling</strong>: depending on an interface
    </p>
    <p>
      Good design has high cohesion and low coupling. Avoid doing work until you
      can no longer avoid it.
    </p>
    <p>
      <strong>DRY</strong>: <strong>Don’t Repeat Yourself</strong>. Don’t
      duplicate code or effort. Every piece of knowledge in system should have
      single unambiguous authoritative representation. DRY reduces cost of
      development.
    </p>
    <h3 id="long-methods-are-bad">Long methods are bad</h3>
    <ul>
      <li>often obsolete comments</li>
      <li>
        many reasons to change
        <ul>
          <li>hard to test, read, remember, reuse, debug</li>
        </ul>
      </li>
      <li>obscured business rules</li>
      <li>leads to duplication</li>
      <li>can’t be optimized by anything</li>
      <li>lot of variables</li>
      <li>low cohesion</li>
      <li>mixed levels</li>
      <li>not dev friendly</li>
      <li>high coupling</li>
    </ul>
    <p>
      A function is small enough if you can see the entire function in a window.
    </p>
    <p><strong>SLAP, Single Level of Abstraction Principle</strong></p>
    <p>Comment why, not what</p>
    <p>
      Compose method pattern: Code should be composed of steps you want to take
      in developing that code’s logic
    </p>
    <p>
      <strong>Don’t violate the Open-Closed Principle</strong> - software,
      module, component, class, whatever should be open for extension but closed
      for modification - abstraction &amp; polymorphism key to make this happen
    </p>
    <p>
      2 options to make enhancement: 1. Change existing code. 2. Add small new
      module to code.
    </p>
    <p>
      Trying to make code extensible: - who can make code extensible - we need
      to know software &amp; domain
    </p>
    <p>3 kinds of people we work with:</p>
    <ol type="1">
      <li>Knows domain well, not software</li>
      <li>Knows no domain, but software well</li>
      <li>Knows domain &amp; software well</li>
    </ol>
    <p>
      Keep in mind <strong>Liskov’s Substitution Principle</strong>: Inheritance
      should be used only for substitutability.
    </p>
    <p>
      What kind of change should i plan for? - don’t try to go overboard and
      make it extensible - find a domain expert and ask if should plan for
      extensibility in this area
    </p>
    <p>Overuse of inheritance</p>
    <p>
      Inheritance demands more from developer than composition or delegation
    </p>
    <p>
      Services of derived class should require no more and promise no less than
      corresponding services of base class.
    </p>
    <p>
      User of base class should be able to use an instance of derived class
      without knowing difference.
    </p>
    <p>Good:</p>
    <ul>
      <li>public v. protected in base v. derived</li>
      <li>
        derived function can’t throw away any new checked exception not thrown
        base unless new exception extends old one being thrown by base class
      </li>
    </ul>
    <p>Use composition or delegation unless you want substitutability</p>
    <p>
      A class should not depend on another class. Both have to depend on an
      abstraction.
    </p>
    <p>
      <strong>Design Patterns</strong>: elegant solutions to repeating problems;
      shows you how to structure calssses and how those talk to each other
    </p>
  </body>
</html>
