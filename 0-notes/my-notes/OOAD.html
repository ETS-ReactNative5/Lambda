<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link
      rel="stylesheet"
      href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
      integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z"
      crossorigin="anonymous"
    />
    <link rel="stylesheet" href="./prism.css" />
    <script async defer src="./prism.js"></script>
  </head>
  <body>
    ;
    <h1 id="object-oriented-analysis-and-design">
      Object-Oriented Analysis and Design
    </h1>
    <h2 id="phases-of-object-oriented-software-development-oosd">
      Phases of Object-Oriented Software Development, OOSD
    </h2>
    <ul>
      <li>analysis</li>
      <li>
        design
        <ul>
          <li>system design</li>
          <li>object design</li>
        </ul>
      </li>
      <li>implementation and testing</li>
    </ul>
    <h2 id="object-oriented-principles">Object-Oriented Principles</h2>
    <p>
      <strong>major elements</strong>: abstraction, encapsulation, modularity,
      hierarchy<br />
      <strong>minor elements</strong>: typing, concurrency, persistence
    </p>
    <ul>
      <li>
        <strong>abstraction</strong>: focus on essential features of an
        element/object in OOP, ignoring extraneous/accidental properties
      </li>
      <li>
        <strong>encapsulation</strong>: process of binding both attributes and
        methods together within a class; internal details within a class; class
        has methods that provide UIs by which the class-provided services may be
        used
      </li>
      <li>
        <strong>modularity</strong>: process of decomposing a problem into a set
        of modules so as to reduce overall problem complexity; intrinsically
        linked with encapsulation; visualized as a way of mapping encapsulated
        abstractions into real physical modules having high cohesion within
        modules and their inter-module interaction or coupling is low
      </li>
      <li>
        <strong>hierarchy</strong>: ranking or ordering of abstraction; system
        can be made up of interrelated subsystems; uses divide-and-conquer
        principle; allows code reusability
        <ul>
          <li>
            two OOA hierarchies
            <ul>
              <li>“is-a”, a rose is a flower</li>
              <li>“part-of”, a petal is part of a flower</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <strong>type</strong>: characterization of a set of elements; in OOP,
        class visualized as a type having properties distinct from any other
        types
      </li>
      <li>
        <strong>typing</strong>: enforcement of notion that an object is
        instance of single class or type; enforces that objects of different
        types may not be interchanged generally, only in restrictive/ed manner
        <ul>
          <li>
            two types of typing:
            <ul>
              <li>
                <strong>strong</strong>: operation on object checked at compile
                time
              </li>
              <li>
                <strong>weak</strong>: messages may be sent to any class;
                operation checked only at execution time
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <strong>concurrency</strong>: allows performing multiple tasks or
        processes simultaneously; single process exists in system = single
        thread of control; most systems have multiple threads; multiple CPU
        systems inherently permit concurrent threads of control; systems running
        on single CPU use algorithms to give equitable CPU time to threads to
        enable concurrency
      </li>
      <li>
        <strong>active object</strong>: independent threads of control executing
        concurrently with threads of other objects; sync with one another as
        well as purely sequential objects
      </li>
      <li>
        <strong>persistence</strong>: property by which object continues to
        exist even after its creator ceases to exist (files, databases)
      </li>
    </ul>
    <h2 id="object-oriented-analysis-ooa">object-oriented analysis, OOA</h2>
    <p>
      procedure of identifying software engineering requirements &amp;
      developing software specs in terms of a software system’s object model,
      comprised of interacting objects
    </p>
    <p>
      difference between OOA and other analysis forms is OOA is centered,
      organized around objects; modeled after real-world objects the system
      interacts with
    </p>
    <p>
      in traditional analysis methodologies, functions &amp; data are considered
      separately
    </p>
    <h3 id="primary-tasks-in-ooa">primary tasks in OOA</h3>
    <ul>
      <li>identifying objects</li>
      <li>organizing objects by creating an object model diagram</li>
      <li>defining object internals or object attributes</li>
      <li>defining object behaviors or object actions</li>
      <li>describing how objects interact</li>
    </ul>
    <p><strong>common models</strong>: use cases &amp; object models</p>
    <h3 id="techniques-for-ooa">techniques for OOA</h3>
    <ul>
      <li>
        <p>
          <strong>object modeling</strong>: developes static structure of
          software system in terms of objects; IDs objects, classes into which
          objects can be grouped, relationships between objects
        </p>
        <ul>
          <li>
            Process:
            <ul>
              <li>ID objects &amp; group into classes</li>
              <li>ID relationships among classes</li>
              <li>create user object model diagram</li>
              <li>define user object attributes</li>
              <li>define operations that should be performed on classes</li>
              <li>review glossary</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p>
          <strong>dynamic modeling</strong>: way of describing how an individual
          object responds to events, either internal or external events
        </p>
        <ul>
          <li>
            Process:
            <ul>
              <li>ID states of each object</li>
              <li>ID events and analyze applicability of actions</li>
              <li>
                construct dynamic model diagram, comprising of state transition
                diagrams
              </li>
              <li>express each state in terms of object attributes</li>
              <li>validate the state-transition diagrams drawn</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p>
          <strong>functional modeling</strong>: shows processes performed within
          an object and how data changes as it moves between methods; specifies
          meaning of operations of object modeling and actions of dynamic
          modeling; corresponds to data flow diagram of traditional structured
          analysis
        </p>
        <ul>
          <li>
            Process:
            <ul>
              <li>ID all inputs and outputs</li>
              <li>
                construct data flow diagrams showing functional dependencies
              </li>
              <li>state purpose of each function</li>
              <li>ID constraints</li>
              <li>specify optimization criteria</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
    <h3 id="structured-analysisstructured-design-sasd">
      structured analysis/structured design (SASD)
    </h3>
    <p>
      traditional approach of software development based upon waterfall model
    </p>
    <ul>
      <li>
        Phases:
        <ul>
          <li>feasibility study</li>
          <li>requirement analysis and specification</li>
          <li>system design</li>
          <li>implementation</li>
          <li>post-implementation review</li>
        </ul>
      </li>
    </ul>
    <h3 id="ooa-v.-sasd-advantages-disadvantages">
      OOA v. SASD Advantages &amp; Disadvantages
    </h3>
    <table>
      <colgroup>
        <col style="width: 18%" />
        <col style="width: 36%" />
        <col style="width: 45%" />
      </colgroup>
      <thead>
        <tr class="header">
          <th style="text-align: center">Type</th>
          <th style="text-align: center">Advantages</th>
          <th style="text-align: center">Disadvantages</th>
        </tr>
      </thead>
      <tbody>
        <tr class="odd">
          <td style="text-align: center">OOD</td>
          <td style="text-align: center">focuses on data, not procedures</td>
          <td style="text-align: center">
            functionality restricted within objects
          </td>
        </tr>
        <tr class="even">
          <td style="text-align: center"></td>
          <td style="text-align: center">
            encapsulation &amp; data hiding help develop systems that can’t be
            tampered with
          </td>
          <td style="text-align: center">
            can’t ID which objects would generate optimal system design
          </td>
        </tr>
        <tr class="odd">
          <td style="text-align: center"></td>
          <td style="text-align: center">
            allows effective management of software complexity by virtue of
            modularity
          </td>
          <td style="text-align: center">
            OOMs don’t easily show comms between objects in system
          </td>
        </tr>
        <tr class="even">
          <td style="text-align: center"></td>
          <td style="text-align: center">
            can be upgraded from small to large easier than SASD
          </td>
          <td style="text-align: center"></td>
        </tr>
        <tr class="odd">
          <td style="text-align: center">SASD</td>
          <td style="text-align: center">
            top-down approach easier to comprehend than OOA
          </td>
          <td style="text-align: center">
            one phase completed before next phase
          </td>
        </tr>
        <tr class="even">
          <td style="text-align: center"></td>
          <td style="text-align: center">
            based upon functionality; gives better understanding of system and
            generates more complete systems
          </td>
          <td style="text-align: center">high initial cost</td>
        </tr>
        <tr class="odd">
          <td style="text-align: center"></td>
          <td style="text-align: center">
            specs written in simple English; can be more easily analyzed by
            non-techies
          </td>
          <td style="text-align: center">doesn’t support code reusability</td>
        </tr>
      </tbody>
    </table>
    <h2 id="object-oriented-design-ood">object-oriented design, OOD</h2>
    <p>involves implementation of the conceptual model produced during OOA</p>
    <ul>
      <li>concepts mapped onto implementing classes</li>
      <li>constraints identified</li>
      <li>interfaces designed</li>
      <li>results in model for solution domain</li>
    </ul>
    <h3 id="implementation-details-include">implementation details include</h3>
    <ul>
      <li>restructuring class data</li>
      <li>
        implementation of methods, internal data structures, and algorithms
      </li>
      <li>implementation of control</li>
      <li>implementation of associations</li>
    </ul>
    <h2 id="object-oriented-programming-oop">
      object-oriented programming, OOP
    </h2>
    <p>
      programming paradigm based upon objects aiming to incorporate modularity
      and reusability advantages
    </p>
    <p>
      <strong>objects</strong>: instances of classes; used to interact with one
      another to design apps
    </p>
    <h3 id="important-features-of-oop">important features of OOP</h3>
    <ul>
      <li>bottom-up approach in program design</li>
      <li>programs organized around objects; grouped in classes</li>
      <li>focus on data with methods to operate upon object’s data</li>
      <li>interaction between objects through functions</li>
      <li>
        reusability of design through new class creation by adding features to
        existing classes
      </li>
    </ul>
    <h2 id="objects">objects</h2>
    <p>
      <strong>object model</strong>: visualizes elements in app in terms of
      objects <strong>object</strong>: real-world element in object-oriented
      environment that may have a physical or conceptual existence
    </p>
    <ul>
      <li>has ID that distinguishes it from other objects</li>
      <li>has state that determines characteristics &amp; values</li>
      <li>
        behavior that represents externally visible activities performed by an
        object in terms of changes in state
      </li>
      <li>can be modeled according to app needs</li>
    </ul>
    <h2 id="classes">classes</h2>
    <p>
      <strong>class</strong>: collection of objects having same characteristic
      properties that exhibit common behavior; gives blueprint or description of
      objects created from it
    </p>
    <p><strong>instantiation</strong>: object creation as member of a class</p>
    <p>
      <strong>class constituents</strong>: set of object attributes instantiated
      from class (class data); set of operations portraying behavior of class
      objects (functions/methods)
    </p>
    <h2 id="encapsulation">encapsulation</h2>
    <p>
      <strong>encapsulation</strong>: process of binding both attributes and
      methods together within class; internal class details can be hidden from
      outside; permits class elements to be accessed from outside only through
      class interface
    </p>
    <p><strong>data hiding</strong>: process of insulting an object’s data</p>
    <p>
      <strong>message passing</strong>: how objects in a system communicate with
      each other
    </p>
    <p>features of message passing:</p>
    <ul>
      <li>between two objects = unidirectional</li>
      <li>enables all interactions between objects</li>
      <li>involves invoking class methods</li>
      <li>objects in different processes can be involved</li>
    </ul>
    <h2 id="inheritance">inheritance</h2>
    <p>
      <strong>inheritance</strong>: mechanism permitting new classes to be
      created out of existing classes by extending and refining capabilities
    </p>
    <ul>
      <li>existing classes = base/parent/super</li>
      <li>
        new classes = derived/child/sub
        <ul>
          <li>
            can inherit attributes and methods off parent(s) provided parent
            allows it
          </li>
          <li>may add its own attributes and methods</li>
          <li>may modify parent’s methods</li>
          <li>defines an “is-a” relationship</li>
        </ul>
      </li>
    </ul>
    <h3 id="types">types</h3>
    <ul>
      <li><strong>single</strong>: sub derives from single parent</li>
      <li><strong>multiple</strong>: sub derives from 2+ parents</li>
      <li>
        <strong>multi-level</strong>: sub derives from parent which has parent,
        etc.
      </li>
      <li>
        <strong>hierarchical</strong>: class has number of subclasses, each of
        which may have subsequence subclasses, for a number of levels to form a
        tree structure
      </li>
      <li>
        <strong>hybrid</strong>: combo of multiple and multilevel to form a
        lattice
      </li>
    </ul>
    <h2 id="polymorphism">polymorphism</h2>
    <ul>
      <li>ability to take multiple forms</li>
      <li>using operations in different ways</li>
      <li>
        allows objects with different internal structures to have a common
        external interface
      </li>
      <li>particularly effective while implementing interface</li>
    </ul>
    <h2 id="generalization-specialization">
      generalization &amp; specialization
    </h2>
    <p>
      generalization and specialization represent hierarchy of relationships
      between classes where subclasses inherit from parents
    </p>
    <p>
      <strong>generalization</strong>: common characteristics of classes
      combined to form a class in a higher level of hierarchy; example
      subclasses combined to form a generalized parent; represents an
      “is-a-kind-of” relationship
    </p>
    <p>
      <strong>specialization</strong>: reverse of generalization; distinguishing
      features of groups of objects are used to form specialized classes from
      existing classes; subclasses are specialized versions of parent
    </p>
    <h2 id="association">association</h2>
    <p>
      <strong>link</strong>: connection through which object collaborates with
      other objects; one object may invoke methods or navigate through another
      object; depicts relationship between two objects; instance of association
    </p>
    <p>
      <strong>association</strong>: group of links having common structure and
      behavior; depicts relationship between objects of 1+ classes
    </p>
    <h3 id="degree-of-an-association">degree of an association</h3>
    <ul>
      <li>denotes number of classes involved in connection</li>
      <li><strong>unary</strong>: connects objects of same class</li>
      <li><strong>binary</strong>: connects objects of 2 classes</li>
      <li><strong>ternary</strong>: connects objects of 3+ classes</li>
    </ul>
    <h3 id="cardinality-ratios-of-associations">
      cardinality ratios of associations
    </h3>
    <p>number of instances participating in association</p>
    <ul>
      <li>one to one</li>
      <li>one to many</li>
      <li>many to many</li>
    </ul>
    <h2 id="aggregation">aggregation</h2>
    <ul>
      <li>composition</li>
      <li>
        relationship among classes by which a class can be made up of any combo
        of objects of other classes
      </li>
      <li>allows objects to be placed directly within body of other classes</li>
      <li>
        “part-of” or “has-a” relationship with ability to navigate from whole to
        parts
      </li>
      <li>object composed of 1+ other objects</li>
      <li>may denote physical or conceptual containment</li>
    </ul>
    <h2 id="object-oriented-modeling-oom">object-oriented modeling, OOM</h2>
    <p>visualizes things in an app by using models organized around objects</p>
    <h3 id="benefits-of-object-model">benefits of object model</h3>
    <ul>
      <li>helps in faster software development</li>
      <li>easy to maintain</li>
      <li>supports relatively hassle-free upgrades</li>
      <li>enables reuse of objects, designs, and functions</li>
      <li>
        reduces development risks, particularly in integration of complex
        systems
      </li>
    </ul>
    <h2 id="dynamic-modeling">dynamic modeling</h2>
    <p>
      represents time-dependent aspects of system; concerned with temporal
      changes in states of objects in a system
    </p>
    <ul>
      <li>
        Main Concepts:
        <ul>
          <li>
            state (situation @ particular condition during object lifetime)
          </li>
          <li>transition (change in state)</li>
          <li>event (occurrence triggering transitions)</li>
          <li>action (computation occurring due to some event)</li>
          <li>concurrency of transitions</li>
        </ul>
      </li>
    </ul>
    <p>
      <strong>state machine</strong>: models object behavior as it passes
      through number of states in its lifetime and actions due to events;
      graphically represented through state transition diagram
    </p>
    <p>
      <strong>state</strong>: abstraction given by values of attributes that
      object has at a particular time period; situation occurring for finite
      period off time in lifetime of an object in which it fulfills certain
      conditions, performs certain activities, or waits for certain events to
      occur; represented by rounded rectangles in state transition diagrams
    </p>
    <ul>
      <li>
        Parts:
        <ul>
          <li>name (optional)</li>
          <li>entry/exit actions</li>
          <li>
            internal transitions (changes within state that don’t cause state
            change)
          </li>
          <li>substates</li>
        </ul>
      </li>
    </ul>
    <p>
      <strong>initial state</strong>: default starting state of object, filled
      black circle
    </p>
    <p>
      <strong>final state</strong>: indicates completion of execution of state
      machine, outlined filled black circle
    </p>
    <p>
      Both initial and final states are pseudo states and may not have the parts
      of regular state except name.
    </p>
    <p>
      <strong>transition</strong>: denotes a change in object state; gives
      relationship between first &amp; new state; graphically represented by
      solid directed arc from source state to destination state
    </p>
    <ul>
      <li>
        5 Parts:
        <ul>
          <li>source state (state affected by transition)</li>
          <li>
            event trigger (occurrence due to which an object in source state
            undergoes transition if guard condition is satisfied)
          </li>
          <li>
            guard condition (if true causes transition on receiving event
            ttrigger)
          </li>
          <li>
            action (uninterruptable and atomic computation ocurring on source
            object due to some event)
          </li>
          <li>target state (destination state after transition completion)</li>
        </ul>
      </li>
    </ul>
    <p>
      <strong>events</strong>: some occurrences that can trigger state
      transition of an object or group of objects; have a location in time and
      space, but do not have time period associated with it; generally
      associated with some actions; ones that trigger transitions are written
      alongside arc of transition in state diagrams
    </p>
    <p>
      <strong>external events</strong>: events that pass from user of system to
      objects within system
    </p>
    <p>
      <strong>internal events</strong>: events that pass from one object to
      another within system
    </p>
    <p>
      <strong>deferred events</strong>: those not immediately handled by object
      in current state, but lined up in a queue to be handled by the object in
      another state later
    </p>
    <p>
      <strong>event class</strong>: group of events with common structure &amp;
      behavior; may also be organized in hierarchical structure; may have
      attributes, time implicit
    </p>
    <p>
      <strong>activity</strong>: operation upon states of an object that
      requires some time period; ongoing executions within system that can be
      interrupted; shown in activity diagrams portraying flow from one activity
      to another
    </p>
    <p>
      <strong>action</strong>: atomic operation executing as a result of certain
      events; may operate upon object on which an event has been triggered or on
      other objects visible to this object; set of actions
    </p>
    <p><strong>atomic</strong>: uninterruptable</p>
    <p><strong>entry action</strong>: action executed upon entering a state</p>
    <p><strong>exit action</strong>: action executed while leaving a state</p>
    <p>
      <strong>scenario</strong>: description of specified sequence of actions;
      depicts behavior of objects undergoing specific action series
    </p>
    <p><strong>primary scenarios</strong>: essential sequences</p>
    <p><strong>secondary scenarios</strong>: alternative sequences</p>
    <ul>
      <li>
        two primary diagrams used for dynamic modeling:
        <ol type="1">
          <li>
            <strong>interaction diagrams</strong>: describe dynamic behavior
            among different objects; comprises set of objects, their
            relationships, and message that objects send and receive; models
            behavior of group of interrelated objects
          </li>
        </ol>
        <ul>
          <li>
            two types:
            <ul>
              <li>
                <strong>sequence</strong>: temporal ordering of messages in
                tabular manner
              </li>
              <li>
                <strong>collaboration</strong>: structural organization of
                objects that send and receive messages through vertices and arcs
              </li>
            </ul>
          </li>
        </ul>
        <ol start="2" type="1">
          <li>
            <strong>state transition diagrams</strong>: describe dynamic
            behavior of single object; illustrates sequences off states an
            object goes through in its lifetime, transition of states, events,
            and conditions causing transition and responses to events
          </li>
        </ol>
      </li>
      <li>
        two types of concurrency:
        <ul>
          <li>
            <strong>system</strong>: concurrency modeled in system level;
            overall system modeled as aggregation of state machines where each
            state machine executes concurrently with others
          </li>
          <li>
            <strong>concurrency within object</strong>: object can issue
            concurrent events; object may have states composed of substates
            &amp; concurrent events may occur in each of substates
          </li>
        </ul>
      </li>
    </ul>
    <p><strong>simple state</strong>: no substructure</p>
    <p>
      <strong>composite state</strong>: state with simpler states nested inside
      it; can have sequential or concurrent substates
    </p>
    <ul>
      <li>substate used generally to reduce complexity of state machine</li>
    </ul>
    <p>
      <strong>sequential substates</strong>: execution control passes from one
      substate to another in a sequential manner; at most one initial state and
      one final state
    </p>
    <p>
      <strong>concurrent substates</strong>: execute in parallel; each state has
      concurrently executing state machines within it; each state machine has
      its own initial and final states; if one finishes first, it waits at final
      state; when all reach final, all join back to single flow
    </p>
    <p>
      <strong>functional modeling</strong>: gives process perspective of OOA
      model and overview of what system is supposed to do; defines function of
      internal processes in system with aid of data flow diagrams (DFDs);
      depicts functional derivation of data values without indicating how they
      are derived when computed or why they need to be computed; represented
      through hierarchy of data flow diagrams
    </p>
    <p>
      <strong>data flow diagram</strong>: graphical representation of a system
      that shows inputs to system, processing upon inputs, system outputs, and
      internal data stores; illustrate series of transformations or computations
      performed on objects or system and external controls and objects that
      affect transformation; four main parts: processes, data flows, actors,
      data stores; other parts: constraints, control flows
    </p>
    <h3 id="data-flow-diagram-features">Data Flow Diagram Features</h3>
    <p>
      <strong>processes</strong>: computational activities that transform data
      values; whole system can be visualized as high-level process; may be
      further divided into smaller components; lowest-level process may be
      simple function; representation in DFD is ellipse with name inside &amp;
      contains fixed number of input &amp; output data values
    </p>
    <p>
      <strong>data flows</strong>: represents flow of data between two
      processes; denotes value of data item at some point of the computations
      &amp; value not changed by data flow; representation in DFD is directed
      arc or arrow &amp; labeled with name of data item it carries; may be
      forked (aggregate to forked components)
    </p>
    <p>
      <strong>actors</strong>: active objects interacting with system by either
      producing data and inputting them to system or consuming data produced by
      system; sources and sinks (?) of data; representation in DFD is rectangle
      &amp; connected to I/Os and lie on DFD boundary
    </p>
    <p>
      <strong>data stores</strong>: passive objects that act as a data
      repository; cannot perform operations; used to store data and retrieve
      stored data; represent a data structure, disk file, or table in database;
      representation in DFD is two parallel lines containing data store name;
      each data store connected to at least one process; input arrows contain
      info to modify data store contents; output arrows contain info retrieved
      from data store &amp; labeled when part of info is to be retrieved;
      two-way arrow implies both retrieval and update
    </p>
    <p>
      <strong>constraint</strong>: specify conditions or restrictions that need
      to be satisfied over time; allow adding new rules or modifying existing
      ones; can appear in all three models of OOA; in object modeling,
      constraints define relationship between objects; in dynamic modeling,
      constraints define relationship between states and events of different
      objects; in functional modeling, constraints define restrictions on
      transformations and computations; representation in DFD is string within
      braces
    </p>
    <p>
      <strong>control flows</strong>: process may be associated within a certain
      Boolean value and is evaluated only if value is true, though is not a
      direct input to process; these Boolean values = control flows;
      representation in DFD is dotted arc from process producing Boolean value
      to process controlled by them
    </p>
    <ul>
      <li>
        to develop DFD model of system, DFD’s hierarchy constructed:
        <ul>
          <li>
            <strong>top level</strong>: single process and actors interacting
            with it; at each successive lower level, further details gradually
            induced (?)
          </li>
          <li>process decomposed into subprocesses</li>
          <li>data flows among subprocesses ID’d</li>
          <li>control flows determined</li>
          <li>data stores defined</li>
          <li>
            while decomposing a process, data flow into or out of process should
            match data flow at next level of DFD
          </li>
        </ul>
      </li>
    </ul>
    <h3 id="advantages-disadvantages">Advantages &amp; Disadvantages</h3>
    <table>
      <colgroup>
        <col style="width: 44%" />
        <col style="width: 55%" />
      </colgroup>
      <thead>
        <tr class="header">
          <th style="text-align: center">Advantages</th>
          <th style="text-align: center">Disadvantages</th>
        </tr>
      </thead>
      <tbody>
        <tr class="odd">
          <td style="text-align: center">
            DFDs depict system boundaries &amp; are helpful in portraying
            relationship between external objects &amp; processes within system
          </td>
          <td style="text-align: center">take a long time to create</td>
        </tr>
        <tr class="even">
          <td style="text-align: center">
            help users have knowledge about system
          </td>
          <td style="text-align: center">
            don’t provide info about time-dependent behavior like when
            transformations are done
          </td>
        </tr>
        <tr class="odd">
          <td style="text-align: center">
            serves as blueprint to develop the system
          </td>
          <td style="text-align: center">
            don’t shed any light on computation frequency or reasons for
            computations
          </td>
        </tr>
        <tr class="even">
          <td style="text-align: center">
            provides detailed info about system processes
          </td>
          <td style="text-align: center">
            complex prep that needs considerable expertise
          </td>
        </tr>
        <tr class="odd">
          <td style="text-align: center">used as part of system docs</td>
          <td style="text-align: center">
            difficult for non-tech person to understand
          </td>
        </tr>
        <tr class="even">
          <td style="text-align: center"></td>
          <td style="text-align: center">
            prep method subjective &amp; leaves ample scope to be imprecise
          </td>
        </tr>
      </tbody>
    </table>
    <ul>
      <li>
        relationship between object, dynamic, and functional models:
        <ul>
          <li>are complimentary to each other for a complete OOA</li>
          <li>
            object modeling develops static structure of software system in
            terms of objects
            <ul>
              <li>slows “doers” of system</li>
            </ul>
          </li>
          <li>
            dynamic modeling develops temporal behavior of objects in response
            to certain events
            <ul>
              <li>shows sequences of operations performed on objects</li>
            </ul>
          </li>
          <li>functional model gives overview of what system should do</li>
        </ul>
      </li>
      <li>
        <p>
          4 main parts of functional model in terms of object model: process,
          actors, data stores, data flows
        </p>
      </li>
      <li>
        dynamic model states when operations are performed while functional
        model states how they are performed and which arguments are needed
        <ul>
          <li>
            as actors are active objects, dynamic model has to specify when it
            acts
          </li>
          <li>
            <p>
              data stores are passive objects and only respond to updates and
              queries; therefore dynamic model need not specify when they act
            </p>
          </li>
          <li>
            dynamic model shows status of objects and operations performed on
            ocurrences of events and subsequent changes in states
            <ul>
              <li>
                state of object as result of changes is shown in the object
                model
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
    <h2 id="uml">UML</h2>
    <p><strong>UML</strong>: Unified Modeling Language</p>
    <p>
      <strong>system</strong>: set off elements organized to achieve certain
      objectives from a system; systems often divided into subsystems and
      described by set of models
    </p>
    <p>
      <strong>model</strong>: simplified complete and consistent abstraction of
      system, created for better understanding of system
    </p>
    <p>
      <strong>view</strong>: projection of a system’s model from a specific
      perspective
    </p>
    <ul>
      <li>
        conceptual model of UML encompasses three major elements: basic building
        blocks, rules, common mechanisms
      </li>
      <li>three building blocks of UML: things, relationships, diagrams</li>
      <li>
        four kinds of things in UML:
        <ul>
          <li>
            <strong>structural</strong>: nouns of UML models representing static
            elements that may be either physical or conceptual class, interface,
            collaboration, use case, active class, components, and nodes
          </li>
          <li>
            <strong>behavioral</strong>: verbs of UML models representing
            dynamic behavior over time and space
            <ul>
              <li>two types: interaction, state machine</li>
            </ul>
          </li>
          <li>
            <strong>grouping</strong>: comprise organizational parts of UML
            model; only one kind of it, package
          </li>
          <li>
            <strong>annotational</strong>: explanations in UML models
            representing comments applied to describe elements
          </li>
        </ul>
      </li>
    </ul>
    <p><strong>relationship</strong>: connection between things</p>
    <ul>
      <li>
        four types:
        <ul>
          <li>
            <strong>dependency</strong>: semantic relationship between two
            things such that a change in one thing brings change in the other
            <ul>
              <li>
                <strong>former</strong>: independent thing;
                <strong>latter</strong>: dependent thing
              </li>
            </ul>
          </li>
          <li>
            <strong>association</strong>: structural relationship representing
            group of links having common structure and behavior
          </li>
          <li>
            <strong>generalization</strong>: generalization/specialization
            relationship in which subclasses inherit structure and behavior from
            super classes (parents)
          </li>
          <li>
            <strong>realization</strong>: semantic relationship between two+
            classifiers such that one classifier lays down a contract that other
            classifiers ensure to abide by
          </li>
        </ul>
      </li>
    </ul>
    <p><strong>diagram</strong>: graphical representation of system</p>
    <ul>
      <li>
        9 types of UML diagrams:
        <ul>
          <li>class</li>
          <li>object</li>
          <li>use case</li>
          <li>sequence</li>
          <li>collaboration</li>
          <li>state chart</li>
          <li>activity</li>
          <li>component</li>
          <li>deployment</li>
        </ul>
      </li>
    </ul>
    <p>
      <strong>rules</strong>: UML has number so models are semantically
      self-consistent and related to other models in system harmoniously
    </p>
    <ul>
      <li>
        UML has semantic rules for: names, scope, visibility, integrity,
        execution
      </li>
      <li>
        UML has four common mechanisms: specifications, adornments, common
        divisions, extensibility mechanisms
      </li>
    </ul>
    <p>
      <strong>specifications</strong>: behind each graphical notation, there is
      a textual statement denoting syntax and semantics; provide semantic
      backplane that contains all parts of system and relationship among
      different paths
    </p>
    <p>
      <strong>adornments</strong>: each UML element has a unique graphical
      notation; notations to represent important aspects of element like name,
      scope, visibility, etc.
    </p>
    <ul>
      <li>
        OO systems divided in two common ways:
        <ul>
          <li>division of classes and objects</li>
          <li>division of interface and implementation</li>
        </ul>
      </li>
    </ul>
    <h3 id="extensibility-mechanisms">extensibility mechanisms</h3>
    <ul>
      <li>
        possible to extend UML capabilities in controlled manner to suit system
        requirements
      </li>
      <li>
        <strong>stereotypes</strong>: extends UML vocabulary through which new
        building blocks can be created out of existing ones
      </li>
      <li>
        <strong>tagged values</strong>: extends properties of UML building
        blocks
      </li>
      <li>
        <p>
          <strong>constraints</strong>: extends semantics of UML building blocks
        </p>
      </li>
      <li>
        class represented by rectangle with three sections
        <ul>
          <li>top section contains class name</li>
          <li>middle section containing class attributes</li>
          <li>bottom section representing class operations</li>
        </ul>
      </li>
      <li>
        visibility of attributes and operations can be represented in following
        ways:
        <ul>
          <li><strong>public</strong>: visible from anywhere in system (+)</li>
          <li><strong>private</strong>: visible only within class (-)</li>
          <li>
            <strong>protected</strong>: visible from within class and children,
            but not outside (#)
          </li>
        </ul>
      </li>
      <li><p>abstract classes are in italics</p></li>
      <li>
        object represented as rectangle with two sections:
        <ul>
          <li>
            <strong>top section</strong>: object name with class/package name
            <ul>
              <li>object-name – class-name</li>
              <li>object-name – class-name :: package-name</li>
              <li>class-name = anonymous objects</li>
            </ul>
          </li>
          <li>
            <strong>bottom section</strong>: represents values of attributes;
            attribute-name = value
          </li>
        </ul>
      </li>
    </ul>
    <p>
      <strong>component</strong>: physical and replaceable part of system that
      confirms to and provides realization of a set of interfaces; represents
      physical packaging of elements like classes and interfaces; represented by
      rectangle with tabs
    </p>
    <p>
      <strong>interface</strong>: collection of methods of class or component;
      specifies set off services that may be provided by class or component;
      drawn as circle together with its name; almost always attached to class or
      component that realizes it
    </p>
    <p>
      <strong>package</strong>: organized group of elements; may contain
      structural things like classes, components, other packages; represented by
      tabbed ffolder; generally only drawn with name, but may have additional
      package details
    </p>
    <table>
      <thead>
        <tr class="header">
          <th style="text-align: center">
            notations for different types of relationships
          </th>
        </tr>
      </thead>
      <tbody>
        <tr class="odd">
          <td style="text-align: center">dependency ————————dashedarrow</td>
        </tr>
        <tr class="even">
          <td style="text-align: center">association (continuous line)</td>
        </tr>
        <tr class="odd">
          <td style="text-align: center">
            direct association ——–&gt; (continuous line)
          </td>
        </tr>
        <tr class="even">
          <td style="text-align: center">
            inheritance (continuous line w/ outline arrow)
          </td>
        </tr>
        <tr class="odd">
          <td style="text-align: center">realization ———————————&gt;</td>
        </tr>
        <tr class="even">
          <td style="text-align: center">
            aggregation (continuous line w/ outline diamond)
          </td>
        </tr>
      </tbody>
    </table>
    <ul>
      <li>
        usually elements in a relationship play specific roles in relationship
        <ul>
          <li>
            role name signifies behavior of an element participating in certain
            context
          </li>
        </ul>
      </li>
      <li>
        UML structural diagrams categorized as follows:
        <ul>
          <li>class diagram</li>
          <li>object diagram</li>
          <li>component diagram</li>
          <li>deployment diagram</li>
        </ul>
      </li>
    </ul>
    <p>
      <strong>class diagram</strong>: models static view of system; comprised of
      classes, interfaces, and collaborations of system and relationships
      between them
    </p>
    <p>
      <strong>object diagram</strong>: models a group of objects and their links
      at a point in time; shows instances off things in a class diagram; static
      part of an interaction diagram
    </p>
    <p>
      <strong>component diagram</strong>: show organization and dependencies
      among group of components; comprised of components, interfaces,
      relationships, packages, and subsystems (optional)
    </p>
    <ul>
      <li>
        used for:
        <ul>
          <li>constructing systems through forward and reverse engineering</li>
          <li>
            modeling config management of source code files while developing
            system using an OOP language
          </li>
          <li>representing schemas in modeling databases</li>
          <li>modeling behaviors of dynamic systems</li>
        </ul>
      </li>
    </ul>
    <p>
      <strong>deployment diagram</strong>: puts emphasis on config of runtime
      processing nodes and their components that live on them; commonly
      comprised off nodes and dependencies on associations between nodes;
    </p>
    <ul>
      <li>
        used to:
        <ul>
          <li>model fully distributed systems</li>
          <li>represent topologies of client/server systems</li>
          <li>
            model devices in embedded systems that typically comprise of
            software-intensive collection of hardware
          </li>
        </ul>
      </li>
      <li>
        UML behavioral diagrams categorized as follows:
        <ul>
          <li>use case diagrams</li>
          <li>interaction diagrams</li>
          <li>state-chart diagrams</li>
          <li>activity diagrams</li>
        </ul>
      </li>
    </ul>
    <p>
      <strong>use case</strong>: describes sequence of actions a system performs
      yielding visible results; shows interaction of things outside system with
      system itself; may be applied to whole system as well as part of system
    </p>
    <p>
      <strong>actor</strong>: represents roles the use-case users play; may be
      person, device, or another system
    </p>
    <ul>
      <li>
        use case diagrams present outside view of manner the elements in a
        system behave and how they can be used in the context
        <ul>
          <li>
            comprised of use cases, actors, relationships like dependency,
            generalization, and association
          </li>
          <li>
            used to model system requirements from outside point of view and to
            model system context by enclosing all system activities within a
            rectangle and focusing on actors outside system by interacting with
            it
          </li>
        </ul>
      </li>
    </ul>
    <p>
      <strong>interaction diagram</strong>: depict interactions of objects and
      their relationships; include messages passed between them; two types:
      sequence and collaboration; used for modeling, control flow by time
      ordering using sequence diagrams, control flow of organization using
      collaboration diagrams
    </p>
    <p>
      <strong>sequence diagram</strong>: interaction diagrams illustrating
      ordering of messages according to time; in form of 2D charts: objects
      initiating interaction placed on X axis, messages sent &amp; received by
      objects placed along Y axis, order of increasing time top to bottom
    </p>
    <p>
      <strong>collaboration diagram</strong>: interaction diagrams illustrating
      structure of objects that send and receive messages; objects participating
      in interaction shown using vertices; links connecting objects used to send
      and receive messages; message shown as labeled arrow
    </p>
    <p>
      <strong>state-chart diagram</strong>: shows state machine depicting
      control flow off object from one state to another; state machine portrays
      sequences of states which an object undergoes due to events and their
      responses to events; comprised of states (simple of composite),
      transitions between states, events causing transitions, actions due to
      events; used for modeling objects which are reactive in nature
    </p>
    <p>
      <strong>activity diagram</strong>: depicts flow of activities which are
      ongoing non-atomic operations in a state machine; activities result in
      actions which are atomic operations; comprised of objects, transitions,
      and activity and action states; used for modeling workflows as viewed by
      actors interacting with system and modeling details of operations or
      computations using flow charts
    </p>
    <p>3 levels of testing:</p>
    <p>
      <strong>unit testing</strong>: individual classes tested; responsibility
      of app engineer who implements structure
      <strong>subsystem testing</strong>: testing a particular module on
      subsystem; responsibility of subsystem lead; involves testing associations
      within subsystem as well as interaction of subsystem with outside; can be
      used as regression tests for each newly released version
      <strong>system testing</strong>: testing whole system; responsibility of
      QA team; often used as regression tests when assembling new releases
    </p>
    <p>OO testing techniques</p>
    <p>
      <strong>gray box</strong>: different types off test cases that can be
      designed for testing OO programs
    </p>
    <ul>
      <li>
        types:
        <ul>
          <li>
            <strong>state model-based testing</strong>: encompasses state
            coverage, state transition coverage, and state transition path
            coverage
          </li>
          <li>
            <strong>use case-based testing</strong>: each scenario in use case
          </li>
          <li>
            <strong>class diagram-based testing</strong>: each class, derived
            class, associations, and aggregations tested
          </li>
          <li>
            <strong>sequence diagram-based testing</strong>: methods in messages
            in sequence diagrams tested
          </li>
        </ul>
      </li>
      <li>
        techniques for subsystem testing:
        <ul>
          <li>
            <strong>thread-based testing</strong>: all classes needed to realize
            a single use case in subsystem integrated and tested
          </li>
          <li>
            <strong>use-based testing</strong>: interfaces and services of
            modules at each level of hierarchy are tested
            <ul>
              <li>
                starts from individual classes to small modules comprising of
                classes, gradually to larger modules, and finally all major
                subsystems
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        categories of system testing:
        <ul>
          <li><strong>alpha testing</strong>: carried out by testing team</li>
          <li>
            <strong>beta testing</strong>: carried out by select group of
            customers
          </li>
          <li>
            <strong>acceptance testing</strong>: carried out by customer before
            accepting deliverables
          </li>
        </ul>
      </li>
      <li>
        <strong>software QA</strong>: methodology that determines extent to
        which a software product is fit for use
        <ul>
          <li>
            activities included for determining software quality:
            <ul>
              <li>auditing</li>
              <li>development of standards and guidelines</li>
              <li>production of reports</li>
              <li>review of quality system</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        Quality Factors:
        <ul>
          <li>
            <strong>correctness</strong>: whether software requirements met
          </li>
          <li>
            <strong>useability</strong>: whether software can be used by
            different user categories
          </li>
          <li>
            <strong>portability</strong>: whether software can operate in
            different platforms with different hardware devices
          </li>
          <li>
            <strong>maintainability</strong>: ease at which errors can be
            connected and modules updated
          </li>
          <li>
            <strong>reusability</strong>: whether modules and classes can be
            reused for developing other software products
          </li>
        </ul>
      </li>
      <li>
        Three categories of OO metrics:
        <ul>
          <li>project</li>
          <li>product</li>
          <li>process</li>
        </ul>
      </li>
      <li>
        <strong>project metrics</strong>: enable PM to assess status and
        performance of an ongoing project
        <ul>
          <li>number of scenario scripts</li>
          <li>number of key classes</li>
          <li>number of support classes</li>
          <li>number of subsystems</li>
        </ul>
      </li>
      <li>
        <strong>product metrics</strong>: measure characteristics of software
        developed
        <ul>
          <li>methods per class</li>
          <li>inheritance structure</li>
          <li>coupling and cohesion</li>
          <li>response for class</li>
        </ul>
      </li>
      <li>
        <strong>process metrics</strong>: measure how a process is performing;
        collected over all projects over long periods off time; used as
        indicators for long-term software process improvements
        <ul>
          <li>
            examples:
            <ul>
              <li>number of kilo lines of code (KLOC)</li>
              <li>defect removal efficiency</li>
              <li>average number of failures detected during testing</li>
              <li>number of latent defects per KLOC</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        after analysis phase, conceptual model developed further into OO model
        using OOD
      </li>
      <li>
        in OOD, tech-independent concepts in analysis model are mapped onto
        implementing classes, constraints are ID’d, interfaces designed,
        resulting in model for solution design
      </li>
      <li>
        <p>
          detailed description constructed specifying how system to be built on
          concrete techs
        </p>
      </li>
      <li>
        stages of OOD:
        <ul>
          <li>definition of system context</li>
          <li>designing system architecture</li>
          <li>ID of objects in system</li>
          <li>construction of design models</li>
          <li>specification of object interface</li>
        </ul>
      </li>
    </ul>
    <p>
      <strong>system context</strong>: has static and dynamic parts; static
      context designed usingg simple block diagram off whole system which is
      expanded into a subsystem hierarchy; subsystem model represented by UML
      packages; dynamic context describes how system interacts with its
      environment, which is modeled using use-case diagrams
    </p>
    <p>
      <strong>system architecture</strong>: designed on basis of context of the
      system in accordance with principles of architecture design as well as
      domain knowledge; typically system partitioned into layers; each layer
      decomposed to form subsystems
    </p>
    <p>
      <strong>decomposition</strong>: dividing large complex system into
      hierarchy of smaller components with lesser complexitties on principles of
      divide-and-conquer
    </p>
    <p><strong>subsystem</strong>: each major component of a system</p>
    <ul>
      <li>
        OO decomposition identifies individual autonomous objects in a system
        and communication among these objects
        <ul>
          <li>
            advantages:
            <ul>
              <li>
                individual components of lesser complexity, more understandable
                and manageable
              </li>
              <li>enables workforce division having specialized skills</li>
              <li>
                allows subsystems to be replaced or modiffied without affecting
                other subsystems
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        concurrency allows two+ objects to receive events at same time and two+
        activities executed simultaneously
        <ul>
          <li>ID’d and represented in dynamic model</li>
          <li>
            to enable each concurrent element assigned thread of control
            <ul>
              <li>
                if concurrency at object level, two concurrent objects are
                assigned two different threads of control
              </li>
              <li>
                if two operations of single object are concurrent in nature,
                that object split among different threads
              </li>
            </ul>
          </li>
          <li>
            associated with problems of data integrity, deadlock, and starvation
          </li>
          <li>clear strategy made whenever concurrency required</li>
          <li>
            requires to be ID’d at design stage itself, can’t be left for
            implementation stage
          </li>
        </ul>
      </li>
      <li>
        <strong>design patterns</strong>: commonly accepted solutions adopted
        for some categories of problems
        <ul>
          <li>
            documented set of building blocks used in certain types of app
            development patterns
          </li>
        </ul>
      </li>
      <li>
        <strong>event</strong>: specification of significant occurrence that has
        a location in time and space
        <ul>
          <li>
            4 types:
            <ul>
              <li>
                <strong>signal</strong>: named object thrown by one object and
                caught by another object
              </li>
              <li>
                <strong>call</strong>: sync event representing dispatch of an
                operation
              </li>
              <li><strong>time</strong>: event representing passage of time</li>
              <li>
                <strong>change</strong>: event representing change in state
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        handling boundary conditions:
        <ul>
          <li>
            system design phase needs to address intialization and termination
            of a system as a whole as well as each subsystem
            <ul>
              <li>
                different documented aspects:
                <ul>
                  <li>start-up of system</li>
                  <li>termination of system</li>
                  <li>
                    initial config of system and reconffig of system when
                    necessary
                  </li>
                  <li>
                    foreseeing failures or undesired termination of system
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        boundary conditions modeled using <strong>boundary use cases</strong>
      </li>
    </ul>
    <p>object design</p>
    <ul>
      <li>
        after subsystem hierarchy developed, system objects ID’d and details
        designed
      </li>
      <li>emphasis shifts from app domain concepts toward computer concepts</li>
      <li>
        <p>
          objects ID’d during analysis are etched out for implementation with an
          aim to minimize execution time, memory consumption, and overall cost
        </p>
      </li>
      <li>
        includes following phases:
        <ul>
          <li>objectID</li>
          <li>
            object representation
            <ul>
              <li>construction of design models</li>
            </ul>
          </li>
          <li>classification of operations</li>
          <li>algo design</li>
          <li>relationships design</li>
          <li>control implementation for external interactions</li>
          <li>package classes and associations into modules</li>
        </ul>
      </li>
      <li>
        object ID = 1st step of object design
        <ul>
          <li>
            grouped into classes and refined so they are suitable for actual
            implementation
          </li>
          <li>
            functions of this stage:
            <ul>
              <li>
                identifying and refining classes in each subsystem or package
              </li>
              <li>defining links and associations between classes</li>
              <li>
                designing hierarchical associations between classes,
                i.e. generalization/specialization and inheritances
              </li>
              <li>designing aggregations</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
    <p>object representation</p>
    <ul>
      <li>
        once classes are ID’d, need to be represented usingg object modeling
        techniques
      </li>
      <li>this stage essentially involves constructing UML diagrams</li>
      <li>
        two types of design models that need to be produced:
        <ul>
          <li>
            <strong>static</strong>: static structure of system using class and
            object diagram
          </li>
          <li>
            <strong>dynamic</strong>: dynamic system structure and show
            interaction between classes using interaction and state-chart
            diagrams
          </li>
        </ul>
      </li>
    </ul>
    <p>operation classification</p>
    <ul>
      <li>
        operation to be performed on objects defined by combining three models
        developed in OOA phase, namely object, dynamic, and functional models
      </li>
      <li>operation specifies what is to be done, not how</li>
      <li>
        following tasks performed regarding operations
        <ul>
          <li>state transition diagram of each object in system developed</li>
          <li>operations defined for events received by objects</li>
          <li>
            cases in which one event triggers other events in same or different
            objects are ID’d
          </li>
          <li>suboperations within actions are ID’d</li>
          <li>main actions expanded to data flow diagrams</li>
        </ul>
      </li>
    </ul>
    <p>algorithm design</p>
    <ul>
      <li>operations in objects are defined using algorithms</li>
      <li>
        <strong>algorithm</strong>: stepwise procedure that solves problem laid
        down in operation; focus on how it’s to be done
      </li>
      <li>
        metrics for choosing optimal algorithm: computational complexity,
        flexibility, understandability
      </li>
    </ul>
    <p>relationships design</p>
    <ul>
      <li>strategory to implement relationships chalked out during OD phase</li>
      <li>
        main relationships addressed comprised of aggregations, associations,
        and inheritances
      </li>
      <li>
        designer should do the following regarding associations:
        <ul>
          <li>ID whether association is uni- or bidirectional</li>
          <li>analyze associations path and update if necessary</li>
          <li>
            implement them as distinct objects in many-to-many or as link to
            other object in one-to-one or one-to-many
          </li>
        </ul>
      </li>
      <li>
        regarding inheritances:
        <ul>
          <li>adjust classes and their associations</li>
          <li>ID abstract classes</li>
          <li>make provisions so behaviors shared when needed</li>
        </ul>
      </li>
    </ul>
    <p>implementation of control</p>
    <ul>
      <li>
        object designer may incorporate refinements in strategy of state-chart
        model
      </li>
      <li>
        in system design, basic strategy for realizing dynamic model is made
      </li>
      <li>
        during OD, this strategy aptly embellished for appropriate
        implementation
      </li>
      <li>
        approaches:
        <ul>
          <li>represent state as location within program</li>
          <li>state machine engine</li>
          <li>control as concurrent tasks</li>
        </ul>
      </li>
      <li>
        packaging classes aspects:
        <ul>
          <li>hiding internal info from outside view</li>
          <li>elements coherence</li>
          <li>
            construction of physical modules
            <ul>
              <li>
                classes in module should represent similar things or components
                in same composite object
              </li>
              <li>closely connected classes, same module</li>
              <li>unconnected/weakly connected, different modules</li>
              <li>
                <strong>modules</strong>: good cohesion, high component
                cooperation
              </li>
              <li>module low coupling with other modules</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        design optimization:
        <ul>
          <li>add redundant associations</li>
          <li>omit nonusable associations</li>
          <li>
            algorithm optimization
            <ul>
              <li>
                obtained by:
                <ul>
                  <li>rearrangement of order of computational tasks</li>
                  <li>
                    reversal of execution order of loops from that laid down in
                    function model
                  </li>
                  <li>removal of dead paths from algorithm</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            save derived attributes to avoid recomputation of complex
            expressions
          </li>
        </ul>
      </li>
      <li>
        design documentation
        <ul>
          <li>
            usage areas:
            <ul>
              <li>software developed by a number of developers</li>
              <li>iterative software development strategies</li>
              <li>developing subsequent versions of software project</li>
              <li>evaluating software</li>
              <li>finding conditions and areas of testing</li>
              <li>software maintenance</li>
            </ul>
          </li>
          <li>
            contents:
            <ul>
              <li>high-level system architecture</li>
              <li>key abstractions and mechanisms</li>
              <li>scenarios that illustrate behavior of main aspects</li>
            </ul>
          </li>
          <li>
            features:
            <ul>
              <li>concise</li>
              <li>well-structured</li>
              <li>unambiguous</li>
              <li>consistent</li>
              <li>complete</li>
              <li>traceable to system’s requirement specs</li>
              <li>diagrammatic instead of descriptive</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        most programming languages don’t provide constructs to implement
        associations directly
      </li>
      <li>
        constraints in classes restrict range and type of values attributes may
        take
        <ul>
          <li>
            valid default value assigned to attribute at object instantiation
          </li>
          <li>when value changed at runtime, checked whether valid value</li>
        </ul>
      </li>
    </ul>
  </body>
</html>
