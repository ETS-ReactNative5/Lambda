<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>react-top-level-api-react (1)</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
  </head>
  <body>
    <p>
      <code>React</code> is the entry point to the React library. If you load
      React from a <code>&lt;script&gt;</code> tag, these top-level APIs are
      available on the <code>React</code> global. If you use ES6 with npm, you
      can write <code>import React from 'react'</code>. If you use ES5 with npm,
      you can write <code>var React = require('react')</code>.
    </p>
    <h2 id="overview">
      <a href="https://reactjs.org/docs/react-api.html#overview"></a>Overview
    </h2>
    <h3 id="components">
      <a href="https://reactjs.org/docs/react-api.html#components"></a
      >Components
    </h3>
    <p>
      React components let you split the UI into independent, reusable pieces,
      and think about each piece in isolation. React components can be defined
      by subclassing <code>React.Component</code> or
      <code>React.PureComponent</code>.
    </p>
    <ul>
      <li>
        <a href="https://reactjs.org/docs/react-api.html#reactcomponent"
          ><code>React.Component</code></a
        >
      </li>
      <li>
        <a href="https://reactjs.org/docs/react-api.html#reactpurecomponent"
          ><code>React.PureComponent</code></a
        >
      </li>
    </ul>
    <p>
      If you don’t use ES6 classes, you may use the
      <code>create-react-class</code> module instead. See
      <a href="https://reactjs.org/docs/react-without-es6.html"
        >Using React without ES6</a
      >
      for more information.
    </p>
    <p>
      React components can also be defined as functions which can be wrapped:
    </p>
    <ul>
      <li>
        <a href="https://reactjs.org/docs/react-api.html#reactmemo"
          ><code>React.memo</code></a
        >
      </li>
    </ul>
    <h3 id="creating-react-elements">
      <a
        href="https://reactjs.org/docs/react-api.html#creating-react-elements"
      ></a
      >Creating React Elements
    </h3>
    <p>
      We recommend
      <a href="https://reactjs.org/docs/introducing-jsx.html">using JSX</a> to
      describe what your UI should look like. Each JSX element is just syntactic
      sugar for calling
      <a href="https://reactjs.org/docs/react-api.html#createelement"
        ><code>React.createElement()</code></a
      >. You will not typically invoke the following methods directly if you are
      using JSX.
    </p>
    <ul>
      <li>
        <a href="https://reactjs.org/docs/react-api.html#createelement"
          ><code>createElement()</code></a
        >
      </li>
      <li>
        <a href="https://reactjs.org/docs/react-api.html#createfactory"
          ><code>createFactory()</code></a
        >
      </li>
    </ul>
    <p>
      See
      <a href="https://reactjs.org/docs/react-without-jsx.html"
        >Using React without JSX</a
      >
      for more information.
    </p>
    <h3 id="transforming-elements">
      <a
        href="https://reactjs.org/docs/react-api.html#transforming-elements"
      ></a
      >Transforming Elements
    </h3>
    <p><code>React</code> provides several APIs for manipulating elements:</p>
    <ul>
      <li>
        <a href="https://reactjs.org/docs/react-api.html#cloneelement"
          ><code>cloneElement()</code></a
        >
      </li>
      <li>
        <a href="https://reactjs.org/docs/react-api.html#isvalidelement"
          ><code>isValidElement()</code></a
        >
      </li>
      <li>
        <a href="https://reactjs.org/docs/react-api.html#reactchildren"
          ><code>React.Children</code></a
        >
      </li>
    </ul>
    <h3 id="fragments">
      <a href="https://reactjs.org/docs/react-api.html#fragments"></a>Fragments
    </h3>
    <p>
      <code>React</code> also provides a component for rendering multiple
      elements without a wrapper.
    </p>
    <ul>
      <li>
        <a href="https://reactjs.org/docs/react-api.html#reactfragment"
          ><code>React.Fragment</code></a
        >
      </li>
    </ul>
    <h3 id="refs">
      <a href="https://reactjs.org/docs/react-api.html#refs"></a>Refs
    </h3>
    <ul>
      <li>
        <a href="https://reactjs.org/docs/react-api.html#reactcreateref"
          ><code>React.createRef</code></a
        >
      </li>
      <li>
        <a href="https://reactjs.org/docs/react-api.html#reactforwardref"
          ><code>React.forwardRef</code></a
        >
      </li>
    </ul>
    <h3 id="suspense">
      <a href="https://reactjs.org/docs/react-api.html#suspense"></a>Suspense
    </h3>
    <p>
      Suspense lets components “wait” for something before rendering. Today,
      Suspense only supports one use case:
      <a href="https://reactjs.org/docs/code-splitting.html#reactlazy"
        >loading components dynamically with <code>React.lazy</code></a
      >. In the future, it will support other use cases like data fetching.
    </p>
    <ul>
      <li>
        <a href="https://reactjs.org/docs/react-api.html#reactlazy"
          ><code>React.lazy</code></a
        >
      </li>
      <li>
        <a href="https://reactjs.org/docs/react-api.html#reactsuspense"
          ><code>React.Suspense</code></a
        >
      </li>
    </ul>
    <h3 id="hooks">
      <a href="https://reactjs.org/docs/react-api.html#hooks"></a>Hooks
    </h3>
    <p>
      <em>Hooks</em> are a new addition in React 16.8. They let you use state
      and other React features without writing a class. Hooks have a
      <a href="https://reactjs.org/docs/hooks-intro.html"
        >dedicated docs section</a
      >
      and a separate API reference:
    </p>
    <ul>
      <li>
        <p>
          <a href="https://reactjs.org/docs/hooks-reference.html#basic-hooks"
            >Basic Hooks</a
          >
        </p>
        <ul>
          <li>
            <a href="https://reactjs.org/docs/hooks-reference.html#usestate"
              ><code>useState</code></a
            >
          </li>
          <li>
            <a href="https://reactjs.org/docs/hooks-reference.html#useeffect"
              ><code>useEffect</code></a
            >
          </li>
          <li>
            <a href="https://reactjs.org/docs/hooks-reference.html#usecontext"
              ><code>useContext</code></a
            >
          </li>
        </ul>
      </li>
      <li>
        <p>
          <a
            href="https://reactjs.org/docs/hooks-reference.html#additional-hooks"
            >Additional Hooks</a
          >
        </p>
        <ul>
          <li>
            <a href="https://reactjs.org/docs/hooks-reference.html#usereducer"
              ><code>useReducer</code></a
            >
          </li>
          <li>
            <a href="https://reactjs.org/docs/hooks-reference.html#usecallback"
              ><code>useCallback</code></a
            >
          </li>
          <li>
            <a href="https://reactjs.org/docs/hooks-reference.html#usememo"
              ><code>useMemo</code></a
            >
          </li>
          <li>
            <a href="https://reactjs.org/docs/hooks-reference.html#useref"
              ><code>useRef</code></a
            >
          </li>
          <li>
            <a
              href="https://reactjs.org/docs/hooks-reference.html#useimperativehandle"
              ><code>useImperativeHandle</code></a
            >
          </li>
          <li>
            <a
              href="https://reactjs.org/docs/hooks-reference.html#uselayouteffect"
              ><code>useLayoutEffect</code></a
            >
          </li>
          <li>
            <a
              href="https://reactjs.org/docs/hooks-reference.html#usedebugvalue"
              ><code>useDebugValue</code></a
            >
          </li>
        </ul>
      </li>
    </ul>
    <hr />
    <h2 id="reference">
      <a href="https://reactjs.org/docs/react-api.html#reference"></a>Reference
    </h2>
    <h3 id="react.component">
      <a href="https://reactjs.org/docs/react-api.html#reactcomponent"></a
      ><code>React.Component</code>
    </h3>
    <p>
      <code>React.Component</code> is the base class for React components when
      they are defined using
      <a
        href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes"
        >ES6 classes</a
      >:
    </p>
    <pre><code>class Greeting extends React.Component {
  render() {
    return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;
  }
}</code></pre>
    <p>
      See the
      <a href="https://reactjs.org/docs/react-component.html"
        >React.Component API Reference</a
      >
      for a list of methods and properties related to the base
      <code>React.Component</code> class.
    </p>
    <hr />
    <h3 id="react.purecomponent">
      <a href="https://reactjs.org/docs/react-api.html#reactpurecomponent"></a
      ><code>React.PureComponent</code>
    </h3>
    <p>
      <code>React.PureComponent</code> is similar to
      <a href="https://reactjs.org/docs/react-api.html#reactcomponent"
        ><code>React.Component</code></a
      >. The difference between them is that
      <a href="https://reactjs.org/docs/react-api.html#reactcomponent"
        ><code>React.Component</code></a
      >
      doesn’t implement
      <a
        href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate"
        ><code>shouldComponentUpdate()</code></a
      >, but <code>React.PureComponent</code> implements it with a shallow prop
      and state comparison.
    </p>
    <p>
      If your React component’s <code>render()</code> function renders the same
      result given the same props and state, you can use
      <code>React.PureComponent</code> for a performance boost in some cases.
    </p>
    <blockquote>
      <p>Note</p>
      <p>
        <code>React.PureComponent</code>’s
        <code>shouldComponentUpdate()</code> only shallowly compares the
        objects. If these contain complex data structures, it may produce
        false-negatives for deeper differences. Only extend
        <code>PureComponent</code> when you expect to have simple props and
        state, or use
        <a href="https://reactjs.org/docs/react-component.html#forceupdate"
          ><code>forceUpdate()</code></a
        >
        when you know deep data structures have changed. Or, consider using
        <a href="https://facebook.github.io/immutable-js/">immutable objects</a>
        to facilitate fast comparisons of nested data.
      </p>
      <p>
        Furthermore, <code>React.PureComponent</code>’s
        <code>shouldComponentUpdate()</code> skips prop updates for the whole
        component subtree. Make sure all the children components are also
        “pure”.
      </p>
    </blockquote>
    <hr />
    <h3 id="react.memo">
      <a href="https://reactjs.org/docs/react-api.html#reactmemo"></a
      ><code>React.memo</code>
    </h3>
    <pre><code>const MyComponent = React.memo(function MyComponent(props) {

});</code></pre>
    <p>
      <code>React.memo</code> is a
      <a href="https://reactjs.org/docs/higher-order-components.html"
        >higher order component</a
      >.
    </p>
    <p>
      If your component renders the same result given the same props, you can
      wrap it in a call to <code>React.memo</code> for a performance boost in
      some cases by memoizing the result. This means that React will skip
      rendering the component, and reuse the last rendered result.
    </p>
    <p>
      <code>React.memo</code> only checks for prop changes. If your function
      component wrapped in <code>React.memo</code> has a
      <a href="https://reactjs.org/docs/hooks-state.html"
        ><code>useState</code></a
      >,
      <a href="https://reactjs.org/docs/hooks-reference.html#usereducer"
        ><code>useReducer</code></a
      >
      or
      <a href="https://reactjs.org/docs/hooks-reference.html#usecontext"
        ><code>useContext</code></a
      >
      Hook in its implementation, it will still rerender when state or context
      change.
    </p>
    <p>
      By default it will only shallowly compare complex objects in the props
      object. If you want control over the comparison, you can also provide a
      custom comparison function as the second argument.
    </p>
    <pre><code>function MyComponent(props) {

}
function areEqual(prevProps, nextProps) {

}
export default React.memo(MyComponent, areEqual);</code></pre>
    <p>
      This method only exists as a
      <strong
        ><a href="https://reactjs.org/docs/optimizing-performance.html"
          >performance optimization</a
        >.</strong
      >
      Do not rely on it to “prevent” a render, as this can lead to bugs.
    </p>
    <blockquote>
      <p>Note</p>
      <p>
        Unlike the
        <a
          href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate"
          ><code>shouldComponentUpdate()</code></a
        >
        method on class components, the <code>areEqual</code> function returns
        <code>true</code> if the props are equal and <code>false</code> if the
        props are not equal. This is the inverse from
        <code>shouldComponentUpdate</code>.
      </p>
    </blockquote>
    <hr />
    <h3 id="createelement">
      <a href="https://reactjs.org/docs/react-api.html#createelement"></a
      ><code>createElement()</code>
    </h3>
    <pre><code>React.createElement(
  type,
  [props],
  [...children]
)</code></pre>
    <p>
      Create and return a new
      <a href="https://reactjs.org/docs/rendering-elements.html"
        >React element</a
      >
      of the given type. The type argument can be either a tag name string (such
      as <code>'div'</code> or <code>'span'</code>), a
      <a href="https://reactjs.org/docs/components-and-props.html"
        >React component</a
      >
      type (a class or a function), or a
      <a href="https://reactjs.org/docs/react-api.html#reactfragment"
        >React fragment</a
      >
      type.
    </p>
    <p>
      Code written with
      <a href="https://reactjs.org/docs/introducing-jsx.html">JSX</a> will be
      converted to use <code>React.createElement()</code>. You will not
      typically invoke <code>React.createElement()</code> directly if you are
      using JSX. See
      <a href="https://reactjs.org/docs/react-without-jsx.html"
        >React Without JSX</a
      >
      to learn more.
    </p>
    <hr />
    <h3 id="cloneelement">
      <a href="https://reactjs.org/docs/react-api.html#cloneelement"></a
      ><code>cloneElement()</code>
    </h3>
    <pre><code>React.cloneElement(
  element,
  [props],
  [...children]
)</code></pre>
    <p>
      Clone and return a new React element using <code>element</code> as the
      starting point. The resulting element will have the original element’s
      props with the new props merged in shallowly. New children will replace
      existing children. <code>key</code> and <code>ref</code> from the original
      element will be preserved.
    </p>
    <p><code>React.cloneElement()</code> is almost equivalent to:</p>
    <pre><code>&lt;element.type {...element.props} {...props}&gt;{children}&lt;/element.type&gt;</code></pre>
    <p>
      However, it also preserves <code>ref</code>s. This means that if you get a
      child with a <code>ref</code> on it, you won’t accidentally steal it from
      your ancestor. You will get the same <code>ref</code> attached to your new
      element.
    </p>
    <p>
      This API was introduced as a replacement of the deprecated
      <code>React.addons.cloneWithProps()</code>.
    </p>
    <hr />
    <h3 id="createfactory">
      <a href="https://reactjs.org/docs/react-api.html#createfactory"></a
      ><code>createFactory()</code>
    </h3>
    <pre><code>React.createFactory(type)</code></pre>
    <p>
      Return a function that produces React elements of a given type. Like
      <a href="https://reactjs.org/docs/react-api.html#createelement"
        ><code>React.createElement()</code></a
      >, the type argument can be either a tag name string (such as
      <code>'div'</code> or <code>'span'</code>), a
      <a href="https://reactjs.org/docs/components-and-props.html"
        >React component</a
      >
      type (a class or a function), or a
      <a href="https://reactjs.org/docs/react-api.html#reactfragment"
        >React fragment</a
      >
      type.
    </p>
    <p>
      This helper is considered legacy, and we encourage you to either use JSX
      or use <code>React.createElement()</code> directly instead.
    </p>
    <p>
      You will not typically invoke <code>React.createFactory()</code> directly
      if you are using JSX. See
      <a href="https://reactjs.org/docs/react-without-jsx.html"
        >React Without JSX</a
      >
      to learn more.
    </p>
    <hr />
    <h3 id="isvalidelement">
      <a href="https://reactjs.org/docs/react-api.html#isvalidelement"></a
      ><code>isValidElement()</code>
    </h3>
    <pre><code>React.isValidElement(object)</code></pre>
    <p>
      Verifies the object is a React element. Returns <code>true</code> or
      <code>false</code>.
    </p>
    <hr />
    <h3 id="react.children">
      <a href="https://reactjs.org/docs/react-api.html#reactchildren"></a
      ><code>React.Children</code>
    </h3>
    <p>
      <code>React.Children</code> provides utilities for dealing with the
      <code>this.props.children</code> opaque data structure.
    </p>
    <h4 id="react.children.map">
      <a href="https://reactjs.org/docs/react-api.html#reactchildrenmap"></a
      ><code>React.Children.map</code>
    </h4>
    <pre><code>React.Children.map(children, function[(thisArg)])</code></pre>
    <p>
      Invokes a function on every immediate child contained within
      <code>children</code> with <code>this</code> set to <code>thisArg</code>.
      If <code>children</code> is an array it will be traversed and the function
      will be called for each child in the array. If children is
      <code>null</code> or <code>undefined</code>, this method will return
      <code>null</code> or <code>undefined</code> rather than an array.
    </p>
    <blockquote>
      <p>Note</p>
      <p>
        If <code>children</code> is a <code>Fragment</code> it will be treated
        as a single child and not traversed.
      </p>
    </blockquote>
    <h4 id="react.children.foreach">
      <a href="https://reactjs.org/docs/react-api.html#reactchildrenforeach"></a
      ><code>React.Children.forEach</code>
    </h4>
    <pre><code>React.Children.forEach(children, function[(thisArg)])</code></pre>
    <p>
      Like
      <a href="https://reactjs.org/docs/react-api.html#reactchildrenmap"
        ><code>React.Children.map()</code></a
      >
      but does not return an array.
    </p>
    <h4 id="react.children.count">
      <a href="https://reactjs.org/docs/react-api.html#reactchildrencount"></a
      ><code>React.Children.count</code>
    </h4>
    <pre><code>React.Children.count(children)</code></pre>
    <p>
      Returns the total number of components in <code>children</code>, equal to
      the number of times that a callback passed to <code>map</code> or
      <code>forEach</code> would be invoked.
    </p>
    <h4 id="react.children.only">
      <a href="https://reactjs.org/docs/react-api.html#reactchildrenonly"></a
      ><code>React.Children.only</code>
    </h4>
    <pre><code>React.Children.only(children)</code></pre>
    <p>
      Verifies that <code>children</code> has only one child (a React element)
      and returns it. Otherwise this method throws an error.
    </p>
    <blockquote>
      <p>Note:</p>
      <p>
        <code>React.Children.only()</code> does not accept the return value of
        <a href="https://reactjs.org/docs/react-api.html#reactchildrenmap"
          ><code>React.Children.map()</code></a
        >
        because it is an array rather than a React element.
      </p>
    </blockquote>
    <h4 id="react.children.toarray">
      <a href="https://reactjs.org/docs/react-api.html#reactchildrentoarray"></a
      ><code>React.Children.toArray</code>
    </h4>
    <pre><code>React.Children.toArray(children)</code></pre>
    <p>
      Returns the <code>children</code> opaque data structure as a flat array
      with keys assigned to each child. Useful if you want to manipulate
      collections of children in your render methods, especially if you want to
      reorder or slice <code>this.props.children</code> before passing it down.
    </p>
    <blockquote>
      <p>Note:</p>
      <p>
        <code>React.Children.toArray()</code> changes keys to preserve the
        semantics of nested arrays when flattening lists of children. That is,
        <code>toArray</code> prefixes each key in the returned array so that
        each element’s key is scoped to the input array containing it.
      </p>
    </blockquote>
    <hr />
    <h3 id="react.fragment">
      <a href="https://reactjs.org/docs/react-api.html#reactfragment"></a
      ><code>React.Fragment</code>
    </h3>
    <p>
      The <code>React.Fragment</code> component lets you return multiple
      elements in a <code>render()</code> method without creating an additional
      DOM element:
    </p>
    <pre><code>render() {
  return (
    &lt;React.Fragment&gt;
      Some text.
      &lt;h2&gt;A heading&lt;/h2&gt;
    &lt;/React.Fragment&gt;
  );
}</code></pre>
    <p>
      You can also use it with the shorthand
      <code>&lt;&gt;&lt;/&gt;</code> syntax. For more information, see
      <a
        href="https://reactjs.org/blog/2017/11/28/react-v16.2.0-fragment-support.html"
        >React v16.2.0: Improved Support for Fragments</a
      >.
    </p>
    <h3 id="react.createref">
      <a href="https://reactjs.org/docs/react-api.html#reactcreateref"></a
      ><code>React.createRef</code>
    </h3>
    <p>
      <code>React.createRef</code> creates a
      <a href="https://reactjs.org/docs/refs-and-the-dom.html">ref</a> that can
      be attached to React elements via the ref attribute.
    </p>
    <pre><code>class MyComponent extends React.Component {
  constructor(props) {
    super(props);

    this.inputRef = React.createRef();  }

  render() {
    return &lt;input type=&quot;text&quot; ref={this.inputRef} /&gt;;  }

  componentDidMount() {
    this.inputRef.current.focus();  }
}</code></pre>
    <h3 id="react.forwardref">
      <a href="https://reactjs.org/docs/react-api.html#reactforwardref"></a
      ><code>React.forwardRef</code>
    </h3>
    <p>
      <code>React.forwardRef</code> creates a React component that forwards the
      <a href="https://reactjs.org/docs/refs-and-the-dom.html">ref</a> attribute
      it receives to another component below in the tree. This technique is not
      very common but is particularly useful in two scenarios:
    </p>
    <ul>
      <li>
        <a
          href="https://reactjs.org/docs/forwarding-refs.html#forwarding-refs-to-dom-components"
          >Forwarding refs to DOM components</a
        >
      </li>
      <li>
        <a
          href="https://reactjs.org/docs/forwarding-refs.html#forwarding-refs-in-higher-order-components"
          >Forwarding refs in higher-order-components</a
        >
      </li>
    </ul>
    <p>
      <code>React.forwardRef</code> accepts a rendering function as an argument.
      React will call this function with <code>props</code> and
      <code>ref</code> as two arguments. This function should return a React
      node.
    </p>
    <pre><code>const FancyButton = React.forwardRef((props, ref) =&gt; (  &lt;button ref={ref} className=&quot;FancyButton&quot;&gt;    {props.children}
  &lt;/button&gt;
));


const ref = React.createRef();
&lt;FancyButton ref={ref}&gt;Click me!&lt;/FancyButton&gt;;</code></pre>
    <p>
      In the above example, React passes a <code>ref</code> given to
      <code>&lt;FancyButton ref={ref}&gt;</code> element as a second argument to
      the rendering function inside the <code>React.forwardRef</code> call. This
      rendering function passes the <code>ref</code> to the
      <code>&lt;button ref={ref}&gt;</code> element.
    </p>
    <p>
      As a result, after React attaches the ref, <code>ref.current</code> will
      point directly to the <code>&lt;button&gt;</code> DOM element instance.
    </p>
    <p>
      For more information, see
      <a href="https://reactjs.org/docs/forwarding-refs.html">forwarding refs</a
      >.
    </p>
    <h3 id="react.lazy">
      <a href="https://reactjs.org/docs/react-api.html#reactlazy"></a
      ><code>React.lazy</code>
    </h3>
    <p>
      <code>React.lazy()</code> lets you define a component that is loaded
      dynamically. This helps reduce the bundle size to delay loading components
      that aren’t used during the initial render.
    </p>
    <p>
      You can learn how to use it from our
      <a href="https://reactjs.org/docs/code-splitting.html#reactlazy"
        >code splitting documentation</a
      >. You might also want to check out
      <a
        href="https://medium.com/@pomber/lazy-loading-and-preloading-components-in-react-16-6-804de091c82d"
        >this article</a
      >
      explaining how to use it in more detail.
    </p>
    <pre><code>
const SomeComponent = React.lazy(() =&gt; import(&#39;./SomeComponent&#39;));</code></pre>
    <p>
      Note that rendering <code>lazy</code> components requires that there’s a
      <code>&lt;React.Suspense&gt;</code> component higher in the rendering
      tree. This is how you specify a loading indicator.
    </p>
    <blockquote>
      <p><strong>Note</strong></p>
      <p>
        Using <code>React.lazy</code>with dynamic import requires Promises to be
        available in the JS environment. This requires a polyfill on IE11 and
        below.
      </p>
    </blockquote>
    <h3 id="react.suspense">
      <a href="https://reactjs.org/docs/react-api.html#reactsuspense"></a
      ><code>React.Suspense</code>
    </h3>
    <p>
      <code>React.Suspense</code> lets you specify the loading indicator in case
      some components in the tree below it are not yet ready to render. Today,
      lazy loading components is the <strong>only</strong> use case supported by
      <code>&lt;React.Suspense&gt;</code>:
    </p>
    <pre><code>
const OtherComponent = React.lazy(() =&gt; import(&#39;./OtherComponent&#39;));

function MyComponent() {
  return (

    &lt;React.Suspense fallback={&lt;Spinner /&gt;}&gt;
      &lt;div&gt;
        &lt;OtherComponent /&gt;
      &lt;/div&gt;
    &lt;/React.Suspense&gt;
  );
}</code></pre>
    <p>
      It is documented in our
      <a href="https://reactjs.org/docs/code-splitting.html#reactlazy"
        >code splitting guide</a
      >. Note that <code>lazy</code> components can be deep inside the
      <code>Suspense</code> tree — it doesn’t have to wrap every one of them.
      The best practice is to place <code>&lt;Suspense&gt;</code> where you want
      to see a loading indicator, but to use <code>lazy()</code> wherever you
      want to do code splitting.
    </p>
    <p>
      While this is not supported today, in the future we plan to let
      <code>Suspense</code> handle more scenarios such as data fetching. You can
      read about this in
      <a href="https://reactjs.org/blog/2018/11/27/react-16-roadmap.html"
        >our roadmap</a
      >.
    </p>
    <blockquote>
      <p>Note:</p>
      <p>
        <code>React.lazy()</code> and <code>&lt;React.Suspense&gt;</code> are
        not yet supported by <code>ReactDOMServer</code>. This is a known
        limitation that will be resolved in the future.
      </p>
    </blockquote>
  </body>
</html>
